"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSelectorCreator = createSelectorCreator;
exports.createSelector = createSelector;
exports.defaultValueEquals = defaultValueEquals;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function createSelectorCreator(valueEquals) {
    return function (selectors, resultFunc) {
        if (!Array.isArray(selectors)) {
            selectors = [selectors];
        }
        var memoizedResultFunc = memoize(resultFunc, valueEquals);
        return function (state) {
            var params = selectors.map(function (selector) {
                return selector(state);
            });
            return memoizedResultFunc(params);
        };
    };
}

function createSelector() {
    return createSelectorCreator(defaultValueEquals).apply(undefined, arguments);
}

function defaultValueEquals(a, b) {
    return a === b;
}

// the memoize function only caches one set of arguments.  This
// actually good enough, rather surprisingly. This is because during
// calculation of a selector result the arguments won't
// change if called multiple times. If a new state comes in, we *want*
// recalculation if and only if the arguments are different.
function memoize(func, valueEquals) {
    var lastArgs = null;
    var lastResult = null;
    return function (args) {
        if (lastArgs !== null && argsEquals(args, lastArgs, valueEquals)) {
            return lastResult;
        }
        lastArgs = args;
        lastResult = func.apply(undefined, _toConsumableArray(args));
        return lastResult;
    };
}

function argsEquals(a, b, valueEquals) {
    return a.every(function (value, index) {
        return valueEquals(value, b[index]);
    });
}